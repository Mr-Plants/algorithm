// 示例代码
function example(n) {
  let i = 0;

  while (i <= n) {
    i = i * 2;
  }
}

/*
时间复杂度：
代码的执行时间T(n)=O(f(n))

首先找出这段代码中和n有关系的代码是第6行，因为代码的执行时间T(n)与代码的执行次数N成正比，
所以如果能知道第6行代码执行了多少次，就知道了执行时间与数量规模n的关系。
变量i每次增大2倍，循环在i>n时结束，所以可以列出不等式 2^N <= n 求得N<=log(n),即T(n)=O(log(n))，
所以这段代码的时间复杂度是O(log(n))

空间复杂度：
因为变量不随数据规模n变化，变量为常数。所以空间复杂度为O(1)
 */

/*
总结规律
1、找出和数据规模相关的代码，如果没有就是常量级复杂度O(1)
2、找出代码终止的条件，列出执行次数的求解函数
3、执行时间T(n)与执行次数N成正比，所以求出N即可知道时间复杂度
 */

/*
递归函数一般是2^n
循环嵌套一般是n^2或者m*n
常见的复杂度为O(1),O(n),O(n^2),O(m*n),O(log n),O(2^n),O(n*log n),O(n^1/2)开根号。
当数据规模n足够大时，忽略常系数等影响，最终应该转化为其中一个
 */